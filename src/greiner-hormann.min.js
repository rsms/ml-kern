/**
 * greiner-hormann v1.4.1
 * Greiner-Hormann clipping algorithm
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.greinerHormann={})}(this,function(t){"use strict";var e=function(t,e){1===arguments.length&&(Array.isArray(t)?(e=t[1],t=t[0]):(e=t.y,t=t.x)),this.x=t,this.y=e,this.next=null,this.prev=null,this._corresponding=null,this._distance=0,this._isEntry=!0,this._isIntersection=!1,this._visited=!1};e.createIntersection=function(t,i,s){var n=new e(t,i);return n._distance=s,n._isIntersection=!0,n._isEntry=!1,n},e.prototype.visit=function(){this._visited=!0,null===this._corresponding||this._corresponding._visited||this._corresponding.visit()},e.prototype.equals=function(t){return this.x===t.x&&this.y===t.y},e.prototype.isInside=function(t){var e=!1,i=t.first,s=i.next,n=this.x,r=this.y;do{(i.y<r&&s.y>=r||s.y<r&&i.y>=r)&&(i.x<=n||s.x<=n)&&(e^=i.x+(r-i.y)/(s.y-i.y)*(s.x-i.x)<n),s=(i=i.next).next||t.first}while(!i.equals(t.first));return e};var i=function(t,e,i,s){this.x=0,this.y=0,this.toSource=0,this.toClip=0;var n=(s.y-i.y)*(e.x-t.x)-(s.x-i.x)*(e.y-t.y);0!==n&&(this.toSource=((s.x-i.x)*(t.y-i.y)-(s.y-i.y)*(t.x-i.x))/n,this.toClip=((e.x-t.x)*(t.y-i.y)-(e.y-t.y)*(t.x-i.x))/n,this.valid()&&(this.x=t.x+this.toSource*(e.x-t.x),this.y=t.y+this.toSource*(e.y-t.y)))};i.prototype.valid=function(){return 0<this.toSource&&this.toSource<1&&0<this.toClip&&this.toClip<1};var s=function(t,i){this.first=null,this.vertices=0,this._lastUnprocessed=null,this._arrayVertices=void 0===i?Array.isArray(t[0]):i;for(var s=0,n=t.length;s<n;s++)this.addVertex(new e(t[s]))};function n(t,e,i,n){var r=new s(t),o=new s(e);return r.clip(o,i,n)}s.prototype.addVertex=function(t){if(null===this.first)this.first=t,this.first.next=t,this.first.prev=t;else{var e=this.first,i=e.prev;e.prev=t,t.next=e,t.prev=i,i.next=t}this.vertices++},s.prototype.insertVertex=function(t,e,i){for(var s,n=e;!n.equals(i)&&n._distance<t._distance;)n=n.next;t.next=n,s=n.prev,t.prev=s,s.next=t,n.prev=t,this.vertices++},s.prototype.getNext=function(t){for(var e=t;e._isIntersection;)e=e.next;return e},s.prototype.getFirstIntersect=function(){var t=this._firstIntersect||this.first;do{if(t._isIntersection&&!t._visited)break;t=t.next}while(!t.equals(this.first));return this._firstIntersect=t,t},s.prototype.hasUnprocessed=function(){var t=this._lastUnprocessed||this.first;do{if(t._isIntersection&&!t._visited)return this._lastUnprocessed=t,!0;t=t.next}while(!t.equals(this.first));return this._lastUnprocessed=null,!1},s.prototype.getPoints=function(){var t=[],e=this.first;if(this._arrayVertices)do{t.push([e.x,e.y]),e=e.next}while(e!==this.first);else do{t.push({x:e.x,y:e.y}),e=e.next}while(e!==this.first);return t},s.prototype.clip=function(t,n,r){var o,h,c=this.first,u=t.first,x=!n&&!r,f=n&&r;do{if(!c._isIntersection)do{if(!u._isIntersection){var p=new i(c,this.getNext(c.next),u,t.getNext(u.next));if(p.valid()){var a=e.createIntersection(p.x,p.y,p.toSource),l=e.createIntersection(p.x,p.y,p.toClip);a._corresponding=l,l._corresponding=a,this.insertVertex(a,c,this.getNext(c.next)),t.insertVertex(l,u,t.getNext(u.next))}}u=u.next}while(!u.equals(t.first));c=c.next}while(!c.equals(this.first));c=this.first,u=t.first,n^=o=c.isInside(t),r^=h=u.isInside(this);do{c._isIntersection&&(c._isEntry=n,n=!n),c=c.next}while(!c.equals(this.first));do{u._isIntersection&&(u._isEntry=r,r=!r),u=u.next}while(!u.equals(t.first));for(var y=[];this.hasUnprocessed();){var d=this.getFirstIntersect(),v=new s([],this._arrayVertices);v.addVertex(new e(d.x,d.y));do{if(d.visit(),d._isEntry)do{d=d.next,v.addVertex(new e(d.x,d.y))}while(!d._isIntersection);else do{d=d.prev,v.addVertex(new e(d.x,d.y))}while(!d._isIntersection);d=d._corresponding}while(!d._visited);y.push(v.getPoints())}return 0===y.length&&(x?o?y.push(t.getPoints()):h?y.push(this.getPoints()):y.push(this.getPoints(),t.getPoints()):f?o?y.push(this.getPoints()):h&&y.push(t.getPoints()):o?y.push(t.getPoints(),this.getPoints()):h?y.push(this.getPoints(),t.getPoints()):y.push(this.getPoints()),0===y.length&&(y=null)),y};var r=n;t.union=function(t,e){return n(t,e,!1,!1)},t.intersection=function(t,e){return n(t,e,!0,!0)},t.diff=function(t,e){return n(t,e,!1,!0)},t.clip=r,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=greiner-hormann.min.js.map
